// in preload scripts, we have access to node.js and electron APIs
// the remote web app will not, so this is safe
const { ipcRenderer: ipc, remote } = require("electron");
const ipcRenderer = require("electron").ipcRenderer;

function createFragment(htmlStr) {
  var frag = document.createDocumentFragment(),
    temp = document.createElement("div");

  temp.innerHTML = htmlStr;

  while (temp.firstChild) {
    frag.appendChild(temp.firstChild);
  }

  return frag;
}

// Generated by CoffeeScript 2.3.2
(function () {
  var BUTTON_CLASS,
    Button,
    Extension,
    HIDDEN_CLASS,
    Node,
    POLLING_INTERVAL,
    Video,
    YouTubeVideoPage;
  BUTTON_CLASS = "popout-for-youtube__button";
  HIDDEN_CLASS = `${BUTTON_CLASS}--hidden`;
  POLLING_INTERVAL = 250;
  Extension = class Extension {
    static openPopout(video) {
      return ipcRenderer.send("popout", {
        action: "openPopout",
        videoId: video.id,
        currentTime: video.currentTime(),
        width: video.width(),
        height: video.height(),
        uniqueId: this.uniqueId(),
      });
    }
    static uniqueId() {
      return Math.random() ^ new Date().getTime();
    }
    static notifyVideoViewed() {
      return null;
    }
  };
  Node = class Node {
    offset() {
      var el, left, top;
      el = this.node;
      left = top = 0;
      while (true) {
        left += el.offsetLeft;
        top += el.offsetTop;
        if (!(el = el.offsetParent)) {
          break;
        }
      }
      return {
        left: left,
        top: top,
      };
    }
    width() {
      return parseInt(this.node.offsetWidth);
    }
    height() {
      return parseInt(this.node.offsetHeight);
    }
    topRightCorner() {
      return {
        x: this.offset().left + this.width(),
        y: this.offset().top,
      };
    }
  };
  Video = function () {
    var selectVideo;
    class Video extends Node {
      constructor(id) {
        super();
        this.id = id;
        this.waitForVideoNode().then((node) => {
          return (this.node = node);
        });
      }
      pause() {
        return this.node.pause();
      }
      play() {
        return this.node.play();
      }
      currentTime() {
        return this.node.currentTime;
      }
      seekTo(time) {
        return (this.node.currentTime = time);
      }
      togglePlayback() {
        if (this.node.paused) {
          return this.node.play();
        } else {
          return this.node.pause();
        }
      }
      waitForVideoNode() {
        return new Promise((resolve) => {
          return setInterval(() => {
            var node;
            node = selectVideo();
            if (node) {
              return resolve(node);
            }
          }, POLLING_INTERVAL);
        });
      }
    }
    selectVideo = function () {
      return document.querySelector("#player video");
    };
    return Video;
  }.call(this);
  Button = class Button extends Node {
    constructor(video1) {
      var button;
      super();
      this.video = video1;
      this.styleInterval = null;
      button = document.createElement("button");
      button.title = "Pop out";
      button.className = `${BUTTON_CLASS} ${HIDDEN_CLASS}`;
      this.node = button;
      this.setClickBehavior();
      this.maintainStyle();
    }
    setClickBehavior() {
      return this.node.addEventListener("click", (event) => {
        this.video.pause();
        return Extension.openPopout(this.video);
      });
    }
    setBottomLeftCorner(point) {
      this.node.style.top = `${point.y - this.height()}px`;
      return (this.node.style.left = `${point.x}px`);
    }
    remove() {
      clearInterval(this.styleInterval);
      return this.node.parentNode.removeChild(this.node);
    }
    maintainStyle() {
      return this.video.waitForVideoNode().then(() => {
        return (this.styleInterval = setInterval(() => {
          this.setDisplay();
          return this.setBottomLeftCorner(this.video.topRightCorner());
        }, POLLING_INTERVAL));
      });
    }
    setDisplay() {
      if (this.node.style.top === "") {
        return this.node.classList.add(HIDDEN_CLASS);
      } else {
        return this.node.classList.remove(HIDDEN_CLASS);
      }
    }
  };
  YouTubeVideoPage = class YouTubeVideoPage {
    constructor() {
      this.previousVideoId = null;
      this.whenVideoChanges(() => {
        try {
          this.button.remove(); // Can fail if the button isn't arleady there. Ignore.
        } catch (error) {}
        this.previousVideoId = this.newVideoId;
        this.newVideoId = this.getVideoId();
        this.video = new Video(this.newVideoId);
        this.button = new Button(this.video);
        document.body.appendChild(this.button.node);
        return Extension.notifyVideoViewed();
      });
    }
    whenVideoChanges(callback) {
      return setInterval(() => {
        if (this.videoChanged()) {
          return callback();
        }
      }, POLLING_INTERVAL);
    }
    videoChanged() {
      return this.getVideoId() !== this.previousVideoId;
    }
    getVideoId() {
      return new URLSearchParams(document.location.search.substring(1)).get(
        "v"
      );
    }
  };
  window.startPiP = function () {
    new YouTubeVideoPage();
  };
}.call(this));

function init() {
  const clear = (() => {
    console.log("trying ad removal method 2");
    const defined = (v) => v !== null && v !== undefined;
    const timeout = setInterval(() => {
      var success = false;
      try {
        document.getElementsByTagName("video")[0].requestPictureInPicture();
        success = true;
        console.log("native pip enabled");
      } catch (e) {}
      //success;

      const ad = [...document.querySelectorAll(".ad-showing")][0];
      if (defined(ad)) {
        console.log("method2: found ad");
        const video = document.querySelector("video");
        if (defined(video) && video.duration) {
          video.currentTime = video.duration;
        }
      }
    }, 500);
    return function () {
      clearTimeout(timeout);
    };
  })();

  document.addEventListener("DOMNodeInserted", function (get_id_and_class) {
    console.warn("DOMNodeInserted");
    var element_id = get_id_and_class.target.id;
    var element_class = get_id_and_class.target.className;

    if (element_class != "" && class_hashmap[element_class] != undefined) {
      hide_elements_class(element_class);
    }

    if (element_id != "" && id_hashmap[element_id] != undefined) {
      hide_elements_id(element_id);
    }
  });

  document.addEventListener("DOMSubtreeModified", function (get_id_and_class) {
    console.warn("DOMSubtreeModified");
    var element_id = get_id_and_class.target.id;
    var element_class = get_id_and_class.target.className;

    if (element_class != "" && class_hashmap[element_class] != undefined) {
      hide_elements_class(element_class);
    }

    if (element_id != "" && id_hashmap[element_id] != undefined) {
      hide_elements_id(element_id);
    }
  });

  function hide_elements_class(element_class) {
    if (element_class) {
      var appBanners = document.getElementsByClassName(element_class);
      [].forEach.call(appBanners, function (appBanner) {
        appBanner.style.display = "none";
        console.log("hided the class" + element_class);
      });
    }
  }

  function hide_elements_id(element_id) {
    document.getElementById(element_id).style.display = "none";
    console.log("hided the id" + element_id);
  }

  document.addEventListener("DOMContentLoaded", function () {
    var allElements = document.getElementsByTagName("*");
    for (var i = 0; i < allElements.length; i++) {
      if (
        allElements[i].id != "" &&
        id_hashmap[allElements[i].id] != undefined
      ) {
        hide_elements_id(allElements[i].id);
      }

      if (
        allElements[i].className != "" &&
        class_hashmap[allElements[i].className] != undefined
      ) {
        hide_elements_class(allElements[i].className);
      }
    }
  });

  // var class_hashmap = { ad1: "ad1", ad2: "ad2" };
  // var id_hashmap = { adid1: "adid1", adid2: adid2 };
}

init();
